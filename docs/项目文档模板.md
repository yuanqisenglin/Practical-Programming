# 基于DSL的多业务场景Agent系统 - 项目文档

## 1. 需求分析说明

### 1.1 项目背景

随着智能客服系统的广泛应用，需要一种灵活的方式来描述不同业务场景下的对话流程。传统的硬编码方式难以维护和扩展，因此需要设计一种领域特定语言（DSL）来描述客服机器人的应答逻辑。

### 1.2 功能需求

1. **DSL脚本语言设计**
   - 支持定义执行步骤（Step）
   - 支持输出话术（Speak）
   - 支持接收用户输入（Listen）
   - 支持条件分支（Branch）
   - 支持变量操作（Set）
   - 支持流程结束（End）

2. **解释器实现**
   - 词法分析：将脚本解析为Token序列
   - 语法分析：构建抽象语法树（AST）
   - 解释执行：执行AST，驱动对话流程

3. **意图识别集成**
   - 集成大语言模型API
   - 对用户自然语言输入进行意图识别
   - 将识别结果传递给解释器

4. **多线程支持**
   - 支持多用户并发访问
   - 每个用户独立的执行上下文
   - 线程安全的变量管理

### 1.3 非功能需求

- 代码规范：遵循Python编码规范
- 可测试性：提供完整的单元测试
- 可扩展性：易于添加新的语法元素
- 文档完整性：提供详细的使用文档

## 2. 概要设计说明

### 2.1 系统架构

```
┌─────────────────┐
│   用户输入      │
└────────┬────────┘
         │
         ▼
┌─────────────────┐
│  意图识别器     │  ← LLM API
└────────┬────────┘
         │
         ▼
┌─────────────────┐
│   解释器        │
│  ┌───────────┐  │
│  │  AST执行  │  │
│  └───────────┘  │
└────────┬────────┘
         │
         ▼
┌─────────────────┐
│  执行上下文     │  ← 多用户管理
└────────┬────────┘
         │
         ▼
┌─────────────────┐
│   系统输出      │
└─────────────────┘
```

### 2.2 模块划分

1. **DSL模块** (`src/dsl/`)
   - `lexer.py`: 词法分析器
   - `parser.py`: 语法分析器
   - `interpreter.py`: 解释器
   - `ast.py`: AST节点定义

2. **LLM模块** (`src/llm/`)
   - `intent_analyzer.py`: 意图识别接口

3. **运行时模块** (`src/runtime/`)
   - `execution_context.py`: 执行上下文管理

4. **主程序** (`src/main.py`)
   - 整合所有模块
   - 提供命令行接口

### 2.3 数据流

1. 脚本文件 → 词法分析 → Token序列
2. Token序列 → 语法分析 → AST
3. 用户输入 → 意图识别 → 意图结果
4. AST + 意图结果 → 解释执行 → 系统输出

## 3. 详细设计说明

### 3.1 词法分析器（Lexer）

**功能**: 将DSL脚本解析为Token序列

**主要类**:
- `Token`: Token数据结构
- `TokenType`: Token类型枚举
- `Lexer`: 词法分析器

**接口定义**:
```python
class Lexer:
    def __init__(self, source: str)
    def tokenize(self) -> List[Token]
```

**关键方法**:
- `read_string()`: 读取字符串字面量
- `read_number()`: 读取数字
- `read_identifier()`: 读取标识符
- `skip_comment()`: 跳过注释

### 3.2 语法分析器（Parser）

**功能**: 将Token序列解析为AST

**主要类**:
- `Parser`: 语法分析器
- `ParseError`: 语法错误异常

**接口定义**:
```python
class Parser:
    def __init__(self, lexer: Lexer)
    def parse(self) -> ScriptNode
    def parse_step(self) -> StepNode
    def parse_speak(self) -> SpeakNode
    def parse_listen(self) -> ListenNode
    def parse_branch(self) -> BranchNode
    def parse_set(self) -> SetNode
```

**语法规则**:
- Script → Step*
- Step → "step" IDENTIFIER "{" Statement* "}"
- Statement → Speak | Listen | Branch | Set | End
- Speak → "speak" STRING
- Listen → "listen" IDENTIFIER
- Branch → "branch" Condition "->" IDENTIFIER
- Set → "set" IDENTIFIER "=" Value
- End → "end"

### 3.3 解释器（Interpreter）

**功能**: 执行AST，驱动对话流程

**主要类**:
- `Interpreter`: 解释器
- `InterpreterError`: 执行错误异常

**接口定义**:
```python
class Interpreter:
    def __init__(self, script: ScriptNode, intent_analyzer: Callable)
    def execute(self, context: ExecutionContext, input_callback: Callable) -> Dict
```

**执行流程**:
1. 从当前Step开始执行
2. 依次执行Step内的语句
3. 遇到Speak：输出话术
4. 遇到Listen：等待用户输入，进行意图识别
5. 遇到Branch：根据条件决定是否跳转
6. 遇到Set：设置变量值
7. 遇到End：结束执行

### 3.4 意图识别器（IntentAnalyzer）

**功能**: 调用LLM API进行意图识别

**主要类**:
- `IntentAnalyzer`: 真实LLM接口
- `MockIntentAnalyzer`: 模拟接口（用于测试）

**接口定义**:
```python
class IntentAnalyzer:
    def __init__(self, api_key: str, model: str)
    def analyze(self, user_input: str, intents: List[str]) -> Dict[str, Any]
```

**返回格式**:
```python
{
    "intent": "意图名称",
    "confidence": 0.0-1.0,
    "entities": {},
    "raw_response": "原始响应"
}
```

### 3.5 执行上下文（ExecutionContext）

**功能**: 管理每个用户的执行状态

**主要类**:
- `ExecutionContext`: 单个用户的执行上下文
- `ContextManager`: 上下文管理器

**接口定义**:
```python
class ExecutionContext:
    def set_variable(self, name: str, value: Any)
    def get_variable(self, name: str) -> Any
    def set_current_step(self, step_name: str)
    def get_current_step(self) -> Optional[str]

class ContextManager:
    def get_context(self, user_id: str) -> ExecutionContext
    def remove_context(self, user_id: str)
```

**线程安全**: 使用`threading.Lock`保证线程安全

## 4. 测试报告

### 4.1 测试策略

- **单元测试**: 对每个模块进行独立测试
- **集成测试**: 测试模块之间的协作
- **功能测试**: 测试完整的业务流程

### 4.2 测试桩和测试驱动

**测试桩**:
- `MockIntentAnalyzer`: 模拟意图识别器，不调用真实API

**测试驱动**:
- `test_lexer.py`: 词法分析器测试
- `test_parser.py`: 语法分析器测试
- `test_interpreter.py`: 解释器测试
- `test_intent_analyzer.py`: 意图识别器测试

### 4.3 测试用例

#### 4.3.1 词法分析器测试

- 基本Token识别
- 字符串转义
- 分支条件Token
- 注释跳过
- 数字识别

#### 4.3.2 语法分析器测试

- 简单Step解析
- Listen语句解析
- Branch语句解析
- Set语句解析
- 多个Step解析
- 语法错误处理

#### 4.3.3 解释器测试

- Speak语句执行
- Branch条件判断
- Set变量设置
- 变量替换
- Step跳转

#### 4.3.4 意图识别器测试

- 订单查询意图识别
- 退款申请意图识别
- 物流查询意图识别
- 未知意图处理
- 结果格式验证

### 4.4 测试结果

运行`python tests/run_tests.py`查看详细测试结果。

## 5. DSL脚本编写指南

详见`docs/DSL语法规范.md`。

## 6. AI辅助编程说明

### 6.1 使用的工具

- **Cursor AI**: 用于代码生成和辅助开发

### 6.2 使用过程

1. **项目初始化**
   - 使用AI生成项目结构和基础代码框架
   - 提示词: "创建一个基于DSL的智能客服系统项目结构"

2. **DSL语法设计**
   - 与AI讨论DSL语法规范
   - 提示词: "设计一个用于描述客服对话流程的DSL语法"

3. **词法分析器实现**
   - AI辅助实现Token识别逻辑
   - 提示词: "实现一个词法分析器，能够识别step、speak、listen等关键字"

4. **语法分析器实现**
   - AI辅助实现AST构建逻辑
   - 提示词: "实现一个递归下降语法分析器，构建AST"

5. **解释器实现**
   - AI辅助实现执行引擎
   - 提示词: "实现一个解释器，能够执行AST并处理条件分支"

6. **测试代码编写**
   - AI辅助生成测试用例
   - 提示词: "为词法分析器编写单元测试"

### 6.3 对AI输出的利用

- **代码结构**: 直接使用AI生成的模块结构
- **算法逻辑**: 参考AI提供的实现思路，根据需求进行调整
- **错误处理**: 添加AI建议的错误处理机制
- **代码优化**: 根据AI建议优化代码性能

### 6.4 人工修改

- 调整代码风格以符合项目规范
- 添加详细的注释和文档
- 优化错误提示信息
- 完善测试用例覆盖

## 7. Git日志

使用`git log`命令查看完整的提交历史。

## 8. 总结

本项目成功实现了一个基于DSL的智能客服系统，具有以下特点：

1. **灵活性**: 通过DSL脚本可以灵活描述不同业务场景
2. **可扩展性**: 模块化设计，易于扩展新功能
3. **可测试性**: 完整的测试覆盖
4. **实用性**: 集成LLM API，支持真实场景应用

未来可以进一步优化：
- 支持更多语法特性（循环、函数等）
- 优化意图识别准确率
- 添加可视化脚本编辑器
- 支持脚本热更新

