# 系统扩展指南

## 如何添加真实业务功能

当前系统提供了完整的DSL解释器和对话流程框架，但业务逻辑部分（如订单查询、退款处理）是模拟的。要对接真实业务，可以通过以下方式扩展：

### 方式1：在解释器中添加业务接口调用

#### 1.1 创建业务服务模块

创建 `src/services/` 目录，添加业务服务：

```python
# src/services/order_service.py
class OrderService:
    """订单服务"""
    
    def query_order(self, order_id: str) -> dict:
        """查询订单信息"""
        # 这里对接真实的数据库或API
        # 例如：
        # result = database.query("SELECT * FROM orders WHERE order_id = ?", order_id)
        # return {
        #     "order_id": order_id,
        #     "status": result.status,
        #     "amount": result.amount,
        #     ...
        # }
        pass
    
    def process_refund(self, order_id: str, reason: str) -> dict:
        """处理退款申请"""
        # 对接真实的退款处理系统
        pass
```

#### 1.2 在解释器中集成业务服务

修改 `src/dsl/interpreter.py`，在执行特定步骤时调用业务服务：

```python
from src.services.order_service import OrderService

class Interpreter:
    def __init__(self, script: ScriptNode, intent_analyzer=None, order_service=None):
        self.script = script
        self.intent_analyzer = intent_analyzer
        self.order_service = order_service or OrderService()
    
    def _execute_speak(self, node: SpeakNode, context: ExecutionContext) -> dict:
        message = self._substitute_variables(node.message, context)
        
        # 如果消息包含业务数据占位符，调用业务服务
        if "${order_info}" in message:
            order_id = context.get_variable("order_id")
            if order_id:
                order_info = self.order_service.query_order(order_id)
                # 格式化订单信息
                formatted_info = self._format_order_info(order_info)
                message = message.replace("${order_info}", formatted_info)
        
        return {
            "status": "running",
            "message": message
        }
```

### 方式2：在DSL脚本中添加函数调用

#### 2.1 扩展DSL语法

在 `src/dsl/ast.py` 中添加新的节点类型：

```python
class CallNode(ASTNode):
    """函数调用节点"""
    def __init__(self, function_name: str, arguments: List[str], line_number: int = 0):
        super().__init__(NodeType.CALL, line_number)
        self.function_name = function_name
        self.arguments = arguments
```

#### 2.2 在Parser中支持函数调用语法

在 `src/dsl/parser.py` 中添加解析逻辑：

```python
def parse_call(self) -> CallNode:
    """解析函数调用语句"""
    # call query_order(order_id)
    token = self.expect(TokenType.CALL, "Expected 'call' keyword")
    line_number = token.line_number
    
    func_token = self.expect(TokenType.IDENTIFIER, "Expected function name")
    function_name = func_token.value
    
    self.expect(TokenType.LPAREN, "Expected '('")
    # 解析参数...
    arguments = []
    # ...
    self.expect(TokenType.RPAREN, "Expected ')'")
    
    return CallNode(function_name, arguments, line_number)
```

#### 2.3 在解释器中执行函数调用

```python
def _execute_call(self, node: CallNode, context: ExecutionContext) -> dict:
    """执行函数调用"""
    # 获取函数参数值
    args = [context.get_variable(arg) for arg in node.arguments]
    
    # 根据函数名调用对应的业务服务
    if node.function_name == "query_order":
        order_id = args[0] if args else None
        result = self.order_service.query_order(order_id)
        # 将结果存储到上下文变量中
        context.set_variable("order_info", result)
        return {"status": "running", "message": "订单查询完成"}
    
    return {"status": "error", "message": f"未知函数: {node.function_name}"}
```

### 方式3：使用外部API调用

#### 3.1 创建API客户端

```python
# src/services/api_client.py
import requests

class APIClient:
    """API客户端"""
    
    def __init__(self, base_url: str, api_key: str):
        self.base_url = base_url
        self.api_key = api_key
    
    def query_order(self, order_id: str) -> dict:
        """调用订单查询API"""
        response = requests.get(
            f"{self.base_url}/api/orders/{order_id}",
            headers={"Authorization": f"Bearer {self.api_key}"}
        )
        return response.json()
```

#### 3.2 在解释器中集成API调用

```python
from src.services.api_client import APIClient

class Interpreter:
    def __init__(self, script: ScriptNode, intent_analyzer=None, api_client=None):
        self.script = script
        self.intent_analyzer = intent_analyzer
        self.api_client = api_client or APIClient(
            base_url=os.getenv("API_BASE_URL"),
            api_key=os.getenv("API_KEY")
        )
```

### 方式4：使用数据库查询

#### 4.1 创建数据库服务

```python
# src/services/database_service.py
import sqlite3  # 或使用其他数据库驱动

class DatabaseService:
    """数据库服务"""
    
    def __init__(self, db_path: str):
        self.db_path = db_path
    
    def query_order(self, order_id: str) -> dict:
        """从数据库查询订单"""
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()
        cursor.execute("SELECT * FROM orders WHERE order_id = ?", (order_id,))
        row = cursor.fetchone()
        conn.close()
        
        if row:
            return {
                "order_id": row[0],
                "status": row[1],
                "amount": row[2],
                # ...
            }
        return None
```

## 完整示例：实现真实订单查询

### 步骤1：创建订单服务

```python
# src/services/order_service.py
class OrderService:
    def query_order(self, order_id: str) -> dict:
        """查询订单信息"""
        # 这里可以对接真实的数据库
        # 示例：使用SQLite
        import sqlite3
        conn = sqlite3.connect("orders.db")
        cursor = conn.cursor()
        cursor.execute("SELECT * FROM orders WHERE order_id = ?", (order_id,))
        row = cursor.fetchone()
        conn.close()
        
        if row:
            return {
                "order_id": row[0],
                "status": row[1],
                "amount": row[2],
                "create_time": row[3]
            }
        return None
```

### 步骤2：修改DSL脚本

```dsl
step query_order {
    speak "好的，我来帮您查询订单信息。"
    speak "请输入您的订单号："
    listen order_id
    # 调用业务服务查询订单
    set order_info = call query_order(order_id)
    branch order_info != null -> show_order_info
    speak "抱歉，未找到订单号为 ${order_id} 的订单。"
    end
}

step show_order_info {
    speak "订单信息："
    speak "订单号：${order_info.order_id}"
    speak "订单状态：${order_info.status}"
    speak "订单金额：￥${order_info.amount}"
    end
}
```

### 步骤3：在解释器中集成

```python
# 在 Interpreter 类中添加
def _execute_call(self, node: CallNode, context: ExecutionContext) -> dict:
    if node.function_name == "query_order":
        order_id = context.get_variable("order_id")
        order_info = self.order_service.query_order(order_id)
        context.set_variable("order_info", order_info)
        return {"status": "running"}
```

## 总结

当前系统提供了：
- ✅ 完整的DSL解释器框架
- ✅ 意图识别和对话流程管理
- ✅ 多线程支持

需要扩展的部分：
- ⚠️ 真实的业务逻辑接口（订单查询、退款处理等）
- ⚠️ 数据库或API对接
- ⚠️ 业务数据处理和格式化

**建议**：
1. 先使用当前框架完成对话流程的设计和测试
2. 然后逐步对接真实的业务接口
3. 可以根据实际需求选择数据库、REST API、或其他服务方式

这样可以将对话流程设计与业务逻辑实现分离，便于维护和扩展。

